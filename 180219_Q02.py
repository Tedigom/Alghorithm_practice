# -*- coding: utf-8 -*-
# python3 180219_Q02.py

'''
180218_Q02의 부분집합 여부 확인 문제를 위한 알고리즘으로 '정렬'을 이용한 알고리즘 이외에 다른
방법이 하나 있다. 그것은 해시(hash) 함수를 이용하는 방법이다.
해시를 이용한 알고리즘은 다음과 같이 간단한 모습을 하고 있다.


<알고리즘 C>
해시 알고리즘에서 핵시믕ㄴ 주어진 재료를 잘게 다져서 최종적인 음식으로 만드는 과정을 담당하는 함수인
해시함수(hash function)에 담겨있다. 해시 함수에게 데이터가 입력되면 해시값(hash value)가 리턴된다.
이 해시값은 데이터를 저장하는 장소인 해시 테이블에서 키값(key value)으로 사용된다. 해시 테이블의 특징은
키값만 주어지면 저장되어 있는 데이터를 검색하는 데 걸리는 시간이 언제나 상숫값에 불과하다는 점이다.
테이블에 저장되어 잇는 데이터의 양이 늘어나도 검색에 걸리는 시간은 거의 변하지 않는다.
'abc'가 해시테이블에 입력되고 나면 해시 함수에 의해서 계산된 키값이 리턴되기 때문에 나중에 'abc'를 다시
해시 테이블에서 꺼내고 싶을때 키 값을 전달하면 저장된 데이터 값이 빠르게 리턴된다.

'알고리즘 C'는 바로 이러한 해시 알고리즘의 특성을 이용하여 집합 B의 원소들을 모두 해시 테이블 안에 집어넣은 다음,
집합 A의 원소를 하나씩 꺼내서 동일한 해시함수를 이용해 해시 키를 구하고, 그 키에 해당하는 값이 테이블 안에
존재하는지 여부를 확인하는 방법이다. 만약 A의 원소가 전부 해시 테이블 안에서 발견되면 A는 B의 부분집합이고,
그렇지 않으면 부분집합이 아니다.

이러한 방법은 집합 B의 원소를 모두 해시 테이블에 저장하는 데 걸리는 시간이 C3n(B의 원소를 한번만 훑고 지나가면 되니까)
이고, A의 원소를 하나씩 거내서 확인하는데 걸리는 시간이 C4m이다.
알고리즘 C가 소비하는 시간은 일반적으로 C3n + C4m이라고 말할 수 있다. --> 알고리즘 B보다 조금더 빠르다.

해시 알고리즘은 다른 알고리즘에 비해 속도가 빠르다는 장점은 잇지만, 해시 테이블의 크기만큼 메모리 용량을
차지 한다는 공간적인 단점이 있다. 어떤 알고리즘의 속도를 향상시키려면, 공간을 희생해야한다.

알고리즘 C는 속도가 m과 n의 크기에 큰 영향을 받지 않으며, 빠르다는 장점이 있지만, 메모리 용량을 상대적으로
많이 사용한다는 단점이 있다. 속도와 공간의 균형을 고려했을때 제일 균형잡힌 성능을 제공하는 알고리즘은
'정렬'과 '검색'이 결합되어있는 알고리즘 B이다.
'''
