# -*- coding: utf-8 -*-
# python3 180218_Q02.py

'''
정렬과 검색의 관계를 쉽게 이해해보자.
다음과 같은 두개의 집합이 있다고 생각해보자
A = {,, ... ,}
B = {,, ... ,}

이때 집합 A가 집합 B의 부분집합인지의 여부를 확인하기 위한 알고리즘을 만들어 보라.

대개 많은 사람들이 우선 생각하는 방법은 무식한힘(burte force)의 방법이다.

<알고리즘 A> - C를 베이스로 한 코드이다.

int i;
int j;

int a[m] = {,, ... ,};
int b[n] = {,, ... ,};

//집합 A의 원소를 하나씩 꺼내기 위한 루프
for (i = 0; i<m; i++)
{
    // 집합 V의 원소를 하나씩 꺼내기 위한 루프
    for(j = 0; j<n ; j++)
    {
    if (a[i] == b[j])
        {
        // 집합 A의 원소가 집합 B에서 발견되었으므로 집합 A에서 다음 원소를 검사하기 위해 for루프를 중단
        break;
        }
    if (j == (n-1))
        {
        //  인덱스 j가 바로 앞의 "break"에 걸리지 않고 n-1에 이르렀다는 사실은
            집합 A의 원소a[i]가 집합 B에 존재하지 않는다는 사실을 의미한다.
            따라서 집합 A가 집합 B의 부분집합이 아니라는 사실을 의미하는 false를 리턴한다.

        return false;
        }
    }
}
//  false를 return 하지 않고 여기까지 이르렀다는 말은 집합 A의 원소가 모두 집합 B에서 발견되었다는 사실을 의미하고
이는 부분집합이라는 사실을 의미한다.
return true;

비록 기능상으로는 하자가 없지만 m과 n의 값이 커지면 이런 식으로 작성된 알고리즘이 실행되는 속도는
일반적으로 각 루프가 실행되는 최대 회수를 서로 곱한 값으로 결정된다. 따라서 이 알고리즘의 경우이는
전체적으로 실행되는 속도가 C1*m*n이 된다.



좀더 효율적인 두번째 알고리즘을 생각해보자. 만약 집합 A와 집합 B가 동일한 순서로(예를 들어 수가 커지는
Ascending 순서로) 정렬되어 있다면, A가 B의 부분집합인지 여부를 확인하는 과정은 훨씬 단순해진다.


<알고리즘 B>
집합 A와 집합 B를 정렬한다. 그다음 A와 B를 읽으면서 필요한 조건을 검사한다. 집합 A의 원소 a에 대응하는
값이 집합 B에서는 b였다고 할때, 집합 A에서 a다음에 존재하는 원소 c에 대응하는 값이 집합 B에서는
찾을때  B의 원소를 처음부터 읽지 않고, b다음에 존재하는 값부터 읽는다.
알고리즘 A와 비슷해보이지만, 정렬을 이용함으로써 알고리즘의 성능이 대폭 개선된다.

이런 알고리즘이 실행되는 일반적인 속도는 C2(mlogm+nlogn)이다.
mlogm과 nlogn은 각각 집합 A와 집합 B를 정렬하는데 걸리는 속도를 나타내고 있으며, C2는 그림을 통해서
살펴보았던 비교 과정에서 소비된는 시간을 나타내는 상수이다.




이진트리 (64층, 5번만에 맞추기) ...
퀵정렬이 정렬 알고리즘 중 제일 간단한 편에 속하는 것 처럼, 이진트리 검색은 검색 알고리즘 중에서 가장 쉽고 간단한
편에 속한다. 트리를 이용하는 검색 알고리즘 중에는 이진 트리 대신 B트리, B- 트리, B+ 트리 를
이용하는 방법도 있고, 그밖에 해싱(hashing)을 이용하는 방법도 있다.

** 좀더 공부해 볼것 : 스트링 매칭(string matching) 알고리즘
KMP(Knuth-Morris-Pratt) 알고리즘, 보이어-무어(Boyer_Moore) 알고리즘, 래빈-카프(Rabin-karp)알고리즘..
'''
